import serial
import paho.mqtt.client as mqtt
import json
import time
from datetime import datetime
import cv2
import requests
import threading
import base64
from io import BytesIO
from PIL import Image

# MQTT Configuration
MQTT_BROKER = "broker.hivemq.com"
MQTT_PORT = 1883
MQTT_TOPIC_PUBLISH = "robot/sensor_data"
MQTT_TOPIC_SUBSCRIBE = "robot/commands"

# Serial Configuration
SERIAL_PORT = "/dev/video0"  # Update to match your serial port
SERIAL_BAUD = 115200

# ThingSpeak Configuration
THINGSPEAK_API_KEY = "T28CU7RMT7LFSDOY"  # Replace with your ThingSpeak Write API Key
THINGSPEAK_VIDEO_FIELD = 1  # Field number for video stream
THINGSPEAK_UPDATE_INTERVAL = 1  # Update interval in seconds

class RobotBridge:
    def __init__(self):
        # Initialize Serial connection
        self.serial = serial.Serial(SERIAL_PORT, SERIAL_BAUD, timeout=1)
        time.sleep(2)  # Wait for Arduino to reset

        # Initialize MQTT client
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message

        # Connect to MQTT broker
        self.client.connect(MQTT_BROKER, MQTT_PORT, 60)
        self.client.loop_start()

        # Initialize video capture
        self.cap = cv2.VideoCapture(0)  # USB camera on port 0
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

        # Start video streaming thread
        self.video_thread = threading.Thread(target=self.stream_video)
        self.video_thread.daemon = True
        self.video_thread.start()

    def on_connect(self, client, userdata, flags, rc):
        print(f"Connected to MQTT broker with code {rc}")
        client.subscribe(MQTT_TOPIC_SUBSCRIBE)

    def on_message(self, client, userdata, msg):
        command = msg.payload.decode()
        print(f"Received command: {command}")
        self.serial.write(f"{command}\n".encode())

    def process_sensor_data(self, data):
        try:
            parts = data.split(':')
            if parts[0] == "SENSOR_DATA":
                sensor_dict = {
                    "timestamp": datetime.now().isoformat(),
                    "ultrasonic_distance": min(float(parts[1]), 200.0),  # Limit to 200cm
                    "ir_left": bool(int(parts[2])),
                    "ir_right": bool(int(parts[3])),
                    "speed_left": float(parts[4]),
                    "speed_right": float(parts[5]),
                    "scenario": int(parts[6]),
                    "servo_position": int(parts[7])
                }
                return json.dumps(sensor_dict)
        except Exception as e:
            print(f"Error processing sensor data: {e}")
        return None

    def stream_video(self):
        while True:
            try:
                ret, frame = self.cap.read()
                if ret:
                    # Convert frame to JPEG
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 60])
                    jpg_as_text = base64.b64encode(buffer).decode()

                    # Upload to ThingSpeak
                    payload = {
                        'api_key': THINGSPEAK_API_KEY,
                        f'field{THINGSPEAK_VIDEO_FIELD}': jpg_as_text
                    }
                    requests.post('https://api.thingspeak.com/update', data=payload)

                time.sleep(THINGSPEAK_UPDATE_INTERVAL)
            except Exception as e:
                print(f"Error in video streaming: {e}")
                time.sleep(1)

    def run(self):
        print("Starting Robot Bridge...")
        while True:
            try:
                if self.serial.in_waiting:
                    line = self.serial.readline().decode().strip()
                    if line.startswith("SENSOR_DATA"):
                        sensor_json = self.process_sensor_data(line)
                        if sensor_json:
                            self.client.publish(MQTT_TOPIC_PUBLISH, sensor_json)

                time.sleep(0.01)
            except Exception as e:  # Catch exceptions in the main loop
                print(f"Error in main loop: {e}")
                time.sleep(1)

    def cleanup(self):
        print("Cleaning up resources...")
        self.client.loop_stop()
        self.client.disconnect()
        self.serial.close()
        if self.cap.isOpened():
            self.cap.release()

if __name__ == "__main__":
    bridge = RobotBridge()
    try:
        bridge.run()
    except KeyboardInterrupt:
        print("\nShutting down...")
        bridge.cleanup()
