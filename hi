import serial
import paho.mqtt.client as mqtt
import json
import time
from datetime import datetime
import cv2
import requests
import threading
import base64

MQTT_BROKER = "broker.hivemq.com"
MQTT_PORT = 1883
MQTT_TOPIC_PUBLISH = "robot/sensor_data"
MQTT_TOPIC_SUBSCRIBE = "robot/commands"

SERIAL_PORT = "/dev/video0"
SERIAL_BAUD = 115200

THINGSPEAK_API_KEY = "T28CU7RMT7LFSDOY"
THINGSPEAK_CHANNEL_ID = "2807000"
THINGSPEAK_UPDATE_INTERVAL = 0.1

class RobotBridge:
    def __init__(self):
        self.serial = serial.Serial(SERIAL_PORT, SERIAL_BAUD, timeout=1)
        time.sleep(2)

        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message

        self.client.connect(MQTT_BROKER, MQTT_PORT, 60)
        self.client.loop_start()

        self.cap = cv2.VideoCapture(0)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

        self.video_thread = threading.Thread(target=self.stream_video)
        self.video_thread.daemon = True
        self.video_thread.start()

    def on_connect(self, client, userdata, flags, rc):
        print(f"Connected to MQTT broker with code {rc}")
        client.subscribe(MQTT_TOPIC_SUBSCRIBE)

    def on_message(self, client, userdata, msg):
        command = msg.payload.decode()
        print(f"Received command: {command}")
        self.serial.write(f"{command}\n".encode())

    def process_sensor_data(self, data):
        try:
            parts = data.split(':')
            if parts[0] == "SENSOR_DATA":
                sensor_dict = {
                    "timestamp": datetime.now().isoformat(),
                    "ultrasonic_distance": min(float(parts[1]), 200.0),
                    "ir_left": bool(int(parts[2])),
                    "ir_right": bool(int(parts[3])),
                    "speed_left": float(parts[4]),
                    "speed_right": float(parts[5]),
                    "scenario": int(parts[6]),
                    "servo_position": int(parts[7])
                }
                return json.dumps(sensor_dict)
        except Exception as e:
            print(f"Error processing sensor data: {e}")
        return None

    def stream_video(self):
        while True:
            try:
                ret, frame = self.cap.read()
                if ret:
                    # Compress and convert frame to JPEG
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 60])
                    # Convert to base64
                    jpg_as_text = base64.b64encode(buffer).decode()
                    
                    # Update ThingSpeak
                    payload = {
                        'api_key': THINGSPEAK_API_KEY,
                        'field1': jpg_as_text
                    }
                    
                    response = requests.post(
                        f'https://api.thingspeak.com/update',
                        data=payload
                    )
                    
                    if response.status_code != 200:
                        print(f"Failed to upload video frame: {response.status_code}")
                        
                time.sleep(THINGSPEAK_UPDATE_INTERVAL)
            except Exception as e:
                print(f"Error in video streaming: {e}")
                time.sleep(1)

    def run(self):
        print("Starting Robot Bridge...")
        while True:
            try:
                if self.serial.in_waiting:
                    line = self.serial.readline().decode().strip()
                    if line.startswith("SENSOR_DATA"):
                        sensor_json = self.process_sensor_data(line)
                        if sensor_json:
                            self.client.publish(MQTT_TOPIC_PUBLISH, sensor_json)
                time.sleep(0.01)
            except Exception as e:
                print(f"Error in main loop: {e}")
                time.sleep(1)

    def cleanup(self):
        print("Cleaning up resources...")
        self.client.loop_stop()
        self.client.disconnect()
        self.serial.close()
        if self.cap.isOpened():
            self.cap.release()

if __name__ == "__main__":
    bridge = RobotBridge()
    try:
        bridge.run()
    except KeyboardInterrupt:
        print("\nShutting down...")
        bridge.cleanup()
