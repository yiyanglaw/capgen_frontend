import serial
import time
import cv2
import paho.mqtt.client as mqtt
import base64
from datetime import datetime
import requests

# ThingSpeak Configuration
WRITE_API_KEY = 'OEH1GUAT6UXH5P6N'
CHANNEL_ID = '2794357'
THINGSPEAK_URL = 'https://api.thingspeak.com/update'

# Serial Configuration (Modify if using a different port)
SERIAL_PORT = '/dev/ttyUSB1'
BAUD_RATE = 9600
THINGSPEAK_INTERVAL = 5  # Upload interval in seconds

# MQTT Configuration for Video Streaming
MQTT_BROKER = "broker.hivemq.com"
MQTT_PORT = 1883
MQTT_TOPIC = "raspberrypi/video_stream"

# Fan Control Thresholds
TEMP_THRESHOLD = 30  # Temperature (¬∞C) to turn on fan
SMOKE_THRESHOLD = 400  # Smoke sensor raw value to turn on fan

class SmartSystem:
    def __init__(self):
        self.arduino = None
        self.connect_arduino()
        self.last_thingspeak_update = 0
        self.fan_status = 0  # 0 = OFF, 1 = ON
        self.mqtt_client = self.setup_mqtt()
        self.cap = cv2.VideoCapture(0)  # USB Camera

    def connect_arduino(self):
        """ Attempt to connect to Arduino and handle reconnections. """
        try:
            self.arduino = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
            time.sleep(2)
            print("‚úÖ Connected to Arduino")
        except Exception as e:
            print(f"‚ùå Error connecting to Arduino: {e}")
            self.arduino = None

    def setup_mqtt(self):
        """ Set up MQTT client for video streaming. """
        client = mqtt.Client()
        try:
            client.connect(MQTT_BROKER, MQTT_PORT, 60)
            print("‚úÖ Connected to MQTT Broker")
        except Exception as e:
            print(f"‚ùå MQTT connection error: {e}")
        return client

    def get_sensor_data(self):
        """ Read and parse data from Arduino """
        if not self.arduino:
            self.connect_arduino()
            return None

        try:
            if self.arduino.in_waiting:
                data = self.arduino.readline().decode().strip().split(',')
                if len(data) == 7:
                    sensor_data = {
                        'temperature': float(data[0]),
                        'humidity': float(data[1]),
                        'people_count': int(data[2]),
                        'light': int(data[3]),      # Raw analog value
                        'smoke': int(data[4]),      # Raw analog value
                        'sound': int(data[5]),      # Raw analog value
                        'door': bool(int(data[6]))
                    }
                    
                    # Update fan status based on temperature and smoke
                    self.update_fan_status(sensor_data)
                    
                    return sensor_data
        except Exception as e:
            print(f"‚ùå Error reading Arduino data: {e}")
            return None

    def update_fan_status(self, sensor_data):
        """ Control fan based on temperature and smoke level """
        if sensor_data['temperature'] > TEMP_THRESHOLD or sensor_data['smoke'] > SMOKE_THRESHOLD:
            self.fan_status = 1  # Turn on fan
        else:
            self.fan_status = 0  # Turn off fan

        try:
            if self.arduino:
                self.arduino.write(f"{self.fan_status}\n".encode())  # Send fan status to Arduino
        except Exception as e:
            print(f"‚ùå Error sending fan status to Arduino: {e}")

    def upload_to_thingspeak(self, sensor_data):
        """ Upload sensor data and fan status to ThingSpeak """
        if not sensor_data:
            return

        payload = {
            'api_key': WRITE_API_KEY,
            'field1': sensor_data['people_count'],
            'field2': sensor_data['temperature'],
            'field3': sensor_data['humidity'],
            'field4': sensor_data['light'],     # Send raw analog value
            'field5': sensor_data['smoke'],     # Send raw analog value
            'field6': sensor_data['sound'],     # Send raw analog value
            'field7': int(sensor_data['door']),
            'field8': self.fan_status           # New Fan Status field
        }

        try:
            response = requests.post(THINGSPEAK_URL, data=payload)
            if response.status_code == 200:
                print(f"‚úÖ Data uploaded at {datetime.now()}")
                print(f"üå° Temp: {sensor_data['temperature']}¬∞C, üíß Humidity: {sensor_data['humidity']}%")
                print(f"üë• People: {sensor_data['people_count']}, üí° Light: {sensor_data['light']}")
                print(f"üî• Smoke: {sensor_data['smoke']}, üîä Sound: {sensor_data['sound']}")
                print(f"üö™ Door: {'Open' if sensor_data['door'] else 'Closed'}, üå¨ Fan: {'ON' if self.fan_status else 'OFF'}")
        except Exception as e:
            print(f"‚ùå ThingSpeak upload error: {e}")

    def stream_video(self):
        """ Capture video frames from USB camera and publish to MQTT broker """
        while True:
            ret, frame = self.cap.read()
            if not ret:
                print("‚ùå Error capturing video")
                continue

            # Encode frame as JPEG
            _, buffer = cv2.imencode('.jpg', frame)
            jpg_as_text = base64.b64encode(buffer).decode("utf-8")

            try:
                self.mqtt_client.publish(MQTT_TOPIC, jpg_as_text)
                print("üì° Video frame published to MQTT")
            except Exception as e:
                print(f"‚ùå MQTT publish error: {e}")

            # Show video locally (optional)
            cv2.imshow('Video Stream', frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

    def run(self):
        """ Main loop for reading data, updating ThingSpeak, and streaming video """
        try:
            print("üöÄ System started. Press Ctrl+C to exit.")
            
            # Start video streaming in a separate thread
            import threading
            video_thread = threading.Thread(target=self.stream_video, daemon=True)
            video_thread.start()

            while True:
                sensor_data = self.get_sensor_data()
                
                current_time = time.time()
                if sensor_data and current_time - self.last_thingspeak_update >= THINGSPEAK_INTERVAL:
                    self.upload_to_thingspeak(sensor_data)
                    self.last_thingspeak_update = current_time
                
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            print("\n‚ùå Program terminated")
            if self.arduino:
                self.arduino.close()
            self.cap.release()
            cv2.destroyAllWindows()
        except Exception as e:
            print(f"‚ùå Error: {e}")
            if self.arduino:
                self.arduino.close()
            self.cap.release()
            cv2.destroyAllWindows()

if __name__ == "__main__":
    try:
        system = SmartSystem()
        system.run()
    except Exception as e:
        print(f"‚ùå Failed to start: {e}")
